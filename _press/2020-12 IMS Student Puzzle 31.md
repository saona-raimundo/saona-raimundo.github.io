---
layout: new
title:  IMS Student Puzzle 31
date: 2020-12-15
link: https://imstat.org/2020/12/15/solution-to-puzzle-31/
---

My solution was selected!

# Solution to Puzzle 31
December 15, 2020

## Student Puzzle Editor Anirban DasGupta writes:

Our respondent Raimundo Julian Saona Urmeneta, who is a PhD student at the Institute of Science and Technology in Austria, has done a lovely and complete job of solving the previous puzzle. Congratulations to Raimundo. We are publishing his answer [below] as an example of clarity and completeness.

The self-avoiding walk problem is incredibly diverse. Limited to the case of the square lattice as in this puzzle, it is obvious that log f(n) is subadditive, so it follows that f(n)1/n converges to some positive number μ. This is classic and appears to have been already noted in Hammersley and Morton’s 1954 JRSS(B) article. In fact, a pointwise inequality holds that is of some use in numerically approximating μ; one has f(n)≥ μn pointwise in n. A reasonable rational approximation to the value of μ is 8/3.

A delightful reference that you will enjoy is Gordon Slade’s survey article in the Princeton Companion to Mathematics.

## Raimundo’s solution:
<p>Imagine a particle conducting a walk on the traditional square lattice, starting at the origin <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false" form="prefix">(</mo><mn>0</mn><mo>,</mo><mn>0</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math>. That is, at any time during the walk, the particle goes one unit distance to either the east, or the west, or the north, or the south. An <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math>-walk is a walk that has taken <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>n</mi><annotation encoding="application/x-tex">n</annotation></semantics></math> steps. The walk is called self-avoiding if the particle does not visit any given state twice.</p>
<p>Let <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math> denote the number of n-walks that are self-avoiding.</p>
<p><strong>Compute <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math> for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn><mo>,</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n = 2, 3</annotation></semantics></math>, and justify how you got these values.</strong></p>
<p>For <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>2</mn></mrow><annotation encoding="application/x-tex">n = 2</annotation></semantics></math>, the only non self-avoiding paths are those that return to the origin, which are only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>4</mn><annotation encoding="application/x-tex">4</annotation></semantics></math>. Then, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mn>2</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><msup><mn>4</mn><mn>2</mn></msup><mo>−</mo><mn>4</mn><mo>=</mo><mn>12</mn></mrow><annotation encoding="application/x-tex">f(2) = 4^2 - 4 = 12</annotation></semantics></math>.</p>
<p>For <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>=</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">n = 3</annotation></semantics></math>, the first two steps of the walk must be a self-avoiding path itself. Then, the third step has three possibilities. Therefore, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mn>3</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>3</mn><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mn>2</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>36</mn></mrow><annotation encoding="application/x-tex">f(3) = 3 f(2) = 36</annotation></semantics></math>.</p>
<p><strong>Compute <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(4)</annotation></semantics></math> if you can, or place it within good lower and upper bounds.</strong></p>
<p>Out of all self-avoiding <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>-walks, there are only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>8</mn><annotation encoding="application/x-tex">8</annotation></semantics></math> of them that can complete a square by adding a fourth step, leaving only <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>2</mn><annotation encoding="application/x-tex">2</annotation></semantics></math> possibilities to complete a <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>4</mn><annotation encoding="application/x-tex">4</annotation></semantics></math>-walk. All other self-avoiding <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math>-walks have <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math> possibilities for a fourth step.</p>
<p>Therefore, <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mn>4</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>3</mn><mo stretchy="false" form="prefix">(</mo><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mn>3</mn><mo stretchy="false" form="postfix">)</mo><mo>−</mo><mn>8</mn><mo stretchy="false" form="postfix">)</mo><mo>+</mo><mn>2</mn><mo stretchy="false" form="prefix">(</mo><mn>8</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>84</mn><mo>+</mo><mn>16</mn><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">f(4) =3(f(3) - 8) + 2(8) = 84 + 16 = 100</annotation></semantics></math>.</p>
<p><strong>Try to give non-trivial lower and upper bounds on <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo></mrow><annotation encoding="application/x-tex">f(n)</annotation></semantics></math> of the form <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><msup><mi>k</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">c k^n</annotation></semantics></math> for <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c &gt; 0</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi><mo>∈</mo><mstyle mathvariant="double-struck"><mi>ℕ</mi></mstyle></mrow><annotation encoding="application/x-tex">k \in \mathbb{N}</annotation></semantics></math>.</strong></p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo><mo>≤</mo><mn>4</mn><mo>⋅</mo><msup><mn>3</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><mfrac><mn>4</mn><mn>3</mn></mfrac><msup><mn>3</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">f(n) \le 4 \cdot 3^{n-1} = \frac{4}{3} 3^n</annotation></semantics></math>, because there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>4</mn><annotation encoding="application/x-tex">4</annotation></semantics></math> initial directions and each next step has at most <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>3</mn><annotation encoding="application/x-tex">3</annotation></semantics></math> possibilities.</p>
<p><math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo><mo>≥</mo><mn>4</mn><mo>⋅</mo><mo stretchy="false" form="prefix">(</mo><mn>2</mn><mo>⋅</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>−</mo><mn>1</mn><mo stretchy="false" form="postfix">)</mo><mo>=</mo><mn>4</mn><mo>⋅</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">f(n) \ge 4 \cdot (2 \cdot 2^{n - 1} - 1) = 4 \cdot 2^n - 4</annotation></semantics></math>, because there are <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mn>4</mn><annotation encoding="application/x-tex">4</annotation></semantics></math> initial directions and then using either (i) the same initial direction, or (ii) a perpendicular direction, will result in a self-avoiding walk. This counting procedure repeats the four paths that uses one direction only, therefore we must correct the counting by substracting four. These bounds means that for all <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mi>N</mi><annotation encoding="application/x-tex">N</annotation></semantics></math> natural number, there exists a constant <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>N</mi></msub><mo>&gt;</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">c_N &gt; 0</annotation></semantics></math> such that <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false" form="prefix">(</mo><mi>n</mi><mo stretchy="false" form="postfix">)</mo><mo>≥</mo><msub><mi>c</mi><mi>N</mi></msub><mo>⋅</mo><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">f(n) \ge c_N \cdot 2^n</annotation></semantics></math> and <math display="inline" xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mo>lim</mo><mrow><mi>N</mi><mo>→</mo><mi>∞</mi></mrow></msub><msub><mi>c</mi><mi>N</mi></msub><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">\lim_{N \to \infty} c_N = 4</annotation></semantics></math>.</p>
